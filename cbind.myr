use std
use regex

use "cpp"
use "parse"
use "tok"

const defineprelude = {defs
	var sb

	sb = std.mksb()

	for def : defs
		match std.strfind(def, "=")
		| `std.Some idx:
			std.sbfmt(sb, "#define {} {}\n", def[0:idx], def[idx+1:])
		| `std.None:
			std.sbfmt(sb, "#define {}\n", def)
		;;
	;;
	-> cb.tokinits(std.sbfin(sb), "<commandline>")
}

const includeall = {incs
	var sb

	sb = std.mksb()
	for inc : incs
		std.sbfmt(sb, "#include <{}>\n", inc)
	;;
	-> cb.tokinits(std.sbfin(sb), "<bind>")
}

const main = {args
	var ts
	var pp
	var cmd
	var incpath
	var sysincpaths
	var defs
	var bindpkg
	var exports

	incpath = "./"
	sysincpaths = [][:]
	defs = [][:]
	exports = [][:]
	bindpkg = ""

	cmd = std.optparse(args, &[
		.argdesc="file.c",
		.minargs=0,
		.maxargs=1,
		.opts=[
			[.opt='b', .arg="pkg", .desc="generate bindings"],
			[.opt='I', .arg="inc", .desc="add 'inc' to your include path"],
			[.opt='E', .arg="exp", .desc="define pattern for object included in binding"],
			[.opt='D', .arg="def", .desc="define a macro in the preprocessor e.g. -Dfoo=bar"],
		][:]
	])

	for opt : cmd.opts
		match opt
		| ('b', bnd): bindpkg = bnd
		| ('I', inc): std.slpush(&sysincpaths, inc)
		| ('D', def): std.slpush(&defs, def)
		| ('E', exp):
			match regex.compile(exp)
			| `std.Ok re: std.slpush(&exports, re)
			| `std.Err _: std.fatal("export pattern invalid: {}\n", exp)
			;;
		| _: std.fatal("unreachable {}\n", opt)
		;;
	;;

	match cmd.args.len
	| 0:
		ts = cb.tokinitf(std.In, "stdin")
	| _:
		incpath = std.dirname(cmd.args[0])
		ts = cb.tokinits("", "<cmd.args[0]>")
	;;

	pp = cb.mkcpp(incpath, sysincpaths)
	cb.cpppushts(pp, includeall(cmd.args))
	cb.cpppushts(pp, ts)
	cb.cpppushts(pp, defineprelude(defs))

	cb.parse(pp)

	std.put("ts          {}\n", ts)
	std.put("cmd         {}\n", cmd)
	std.put("incpath     {}\n", incpath)
	std.put("sysincpaths {}\n", sysincpaths)
	std.put("defs        {}\n", defs)
	std.put("bindpkg     {}\n", bindpkg)
	std.put("exports     {}\n", exports)

	for r : exports
		regex.free(r)
	;;
}
